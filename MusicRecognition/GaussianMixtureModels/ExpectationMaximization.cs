using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Accord.Statistics.Distributions.Fitting;
using System.Threading;

namespace MusicRecognition.GaussianMixtureModels
{
    class ExpectationMaximization
    {
        private Cluster[] _cluster;
        private double[,] _r;
        private List<double[][]> _dataSet;

        private int AllMembers
        {
            get
            {
                return _dataSet.Count;
            }
        }

        /// <summary>
        /// Creates new instance of EM algorithm
        /// </summary>
        /// <param name="cluster">Initial values of clusters (should be generated by kMeans)</param>
        /// <param name="dataSet">MFCC vectors of each song</param>
        public ExpectationMaximization(Cluster[] cluster, List<double[][]> dataSet)
        {
            _cluster = cluster;
            _dataSet = dataSet;
        }

        /// <summary>
        /// Computes one iteration of EM algorithm
        /// </summary>
        public void Compute()
        {
            // E-step
            ComputeR(_dataSet);
            // M-step
            for (int i = 0; i < _cluster.Length; i++)
                UpdateCluster(i);
        }

        /// <summary>
        /// Computes maximum of gaussian distributions for specified song
        /// </summary>
        /// <param name="song">MFCC vectors of song</param>
        /// <returns>Maximum value of gaussian distributions</returns>
	    public double GetGaussianMixtureMax(double[][] song)
	    {
		    double[] allGaussianValues;
		    GetGaussianMixtureSum(song, out allGaussianValues);
		    return allGaussianValues.Max();
	    }

	    private double GetGaussianMixtureSum(double[][] song, out double[] allGaussianValues)
	    {
			double sum = 0;
			allGaussianValues = new double[_cluster.Length];
			for (int j = 0; j < _cluster.Length; j++)
			{
				allGaussianValues[j] = _cluster[j].GetGaussianValue(song);
				sum += allGaussianValues[j];
			}

			return sum;
		}

        private void ComputeR(List<double[][]> dataSet)
        {
            _r = new double[dataSet.Count, _cluster.Length];

            // init threads
            ManualResetEvent[] doneEvents = new ManualResetEvent[dataSet.Count];

            for (int ind = 0; ind < dataSet.Count; ind++)
            {
                doneEvents[ind] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem((obj) =>
                {
                    int i = (int)obj;
                    double[] gaussianValues;
	                double sum = GetGaussianMixtureSum(dataSet[i], out gaussianValues);
				    double[] probabilities = MathHelper.ScaleGaussiansToProbabilities(gaussianValues, sum);
                    for (int j = 0; j < _r.GetLength(1); j++)
                        _r[i, j] = probabilities[j];
                    doneEvents[i].Set();
                }, ind);
            }
            foreach (var e in doneEvents)
                e.WaitOne();
        }

        private void UpdateCluster(int clusterInd)
        {
            // Members
            double sum = 0;
            for (int i = 0; i < _r.GetLength(0); i++)
                sum += _r[i, clusterInd];
            _cluster[clusterInd].Members = sum;

            // Weight
            _cluster[clusterInd].Weight = _cluster[clusterInd].Members / AllMembers;

            // mean 
            double[] weights = new double[_dataSet.Count];
            for (int i = 0; i < weights.Length; i++)
                weights[i] = _r[i, clusterInd];
            _cluster[clusterInd].Mean = MathHelper.GetMeanVector(_dataSet, weights);

            // covariance
            _cluster[clusterInd].Covariance = MathHelper.GetMeanCovariance(_dataSet, _cluster[clusterInd].Mean);
        }
    }
}
